import { Image, Notes, Head } from "mdx-deck";

import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";

import {
  vsDark as naiveTheme,
  nightOwl as smartTheme
} from "@code-surfer/themes"


import myTheme from './lib/theme'
export const theme = myTheme
//export const theme = smartTheme;

import beach from "./diagrams/beach.jpg";
import konyuhov1 from "./diagrams/konyuhov1.jpg";
import konyuhov2 from "./diagrams/konyuhov2.jpg";
import konyuhov3 from "./diagrams/konyuhov3.jpg";
import konyuhov4 from "./diagrams/konyuhov4.jpg";
import konyuhov5 from "./diagrams/konyuhov5.jpg";
import konyuhov6 from "./diagrams/konyuhov6.jpg";
import konyuhov61 from "./diagrams/konyuhov61.jpg";
import konyuhov7 from "./diagrams/konyuhov7.jpg";
import nakedInMountains from "./diagrams/nakedInMountains.jpg";
import modulesCosmicStation from "./diagrams/modulesCosmicStation.jpg";
import legoModules from "./diagrams/legoModules.png";

 
import climbersBunch2 from "./diagrams/climbersBunch2.jpg";

import packagesClient0 from "./diagrams/packagesClient0.svg";
import packagesClient1 from "./diagrams/packagesClient1.svg";
import packagesClient from "./diagrams/packagesClient.svg";
import packages from "./diagrams/packages.svg";
import packagesDependencies from "./diagrams/packagesDependencies.svg";
import packagesDependenciesFlowControl from "./diagrams/packagesDependenciesFlowControl.svg";

import layerModule from "./diagrams/layerModule.svg";
import layerModule1 from "./diagrams/layerModule1.svg";

import caLayerModulesBase from "./diagrams/caLayerModulesBase.svg";
import caLayerModulesBaseRequired from "./diagrams/caLayerModulesBaseRequired.svg";
import caLayerModulesBase1 from "./diagrams/caLayerModulesBase1.svg";
import caLayerModulesBase2 from "./diagrams/caLayerModulesBase2.svg";

import counterResetModule from "./diagrams/counterResetModule.svg";
import counterResetModuleImplementation from "./diagrams/counterResetModuleImplementation.svg";

import template from "./diagrams/template.svg";

<Head>
  <title>Стартер для Чистой Архитектуры</title>
</Head>

---

# Как смотреть эту презентацию

<Notes>

Как смотреть эту презентацию

</Notes>

---

<p style="font-size: 80px; text-align:center;">
Всем, кто смотрит из браузера нужно включить режим <i>Заметки докладчика</i>:
</p>
<p style="font-size: 80px; padding-bottom:140px;">
    <ul>
        <li><i>Alt+P</i> - на Windows</li>
        <li><i>Option+P</i> - на Mac</li>
    </ul>
</p>


<Notes>

Теперь вы видите сопровождающий текст.

При необходимости используйте клавиши:
- *F11* - включение/выключение полноэкранного режима
- Для настройки размера шрифта:
  - *Ctrl & '-/+'* - на Windows
  - *Command & '-/+'* - на Mac
- Для навигации используйте стрелки

</Notes>

---

<p style="font-size: 180px; text-align:center; padding-bottom:140px;">
Стартер для
<br/>
Чистой Архитектуры
</p>

<Notes>

Это первая из серии презентаций о стартере для клиентских приложений, разрабатываемых на принципах *Чистой Архитектуры*.

Несмотря на то, что предметная область и, соответственно, бизнес-логика стартера предельно минималистичны - это
простейший счётчик с функциями инкремента и сброса, рассмотрение всех значимых аспектов трудно уместить в одной
презентации.  

Поэтому здесь будет показано лишь самое существенное: как принципы *Чистой Архитектуры* могут быть представлены в коде,
в данном случае, в коде *TypeScript*.

</Notes>

---

<p style="font-size: 100px; text-align:center; padding-bottom:80px;">
Целевая аудитория
</p>

<Notes>

От аудитории желательно присутствие хотя бы минимального предварительного понимания существа проблем, решаемых *Чистой
Архитектурой*.

Ну а для тех, кому эта тема совсем незнакома, сформулируем кратко: принципы *Чистой Архитектуры* направлены на
обеспечение долгого и устойчивого развития программного продукта, своего рода "масштабируемости во времени".  

</Notes>

---

<p style="font-size: 100px; text-align:center; padding-bottom:140px;">
Ключевые свойства стартера
</p>

<Notes>

Ключевые свойства стартера:

</Notes>

---

- *Чистая Архитектура*

<Notes>

*Чистая Архитектура* - главное, для чего создавался стартер.

В общих чертах стартер отражает актуальный взгляд автора (не исключено, что он может измениться) на то, каким должно
быть frontend-приложение, разрабатываемое на принципах *Чистой Архитектуры*, в частности, на *TypeScript*.

</Notes>

---

- *Чистая Архитектура*
- *React*

<Notes>

В качестве UI-фреймворка используется *React*.

На это несколько причин, не самая последняя из которых - популярность фреймворка среди разработчиков.

</Notes>

---

- *Чистая Архитектура*
- *React*
- *TypeScript*

<Notes>

Стартер написан на *TypeScript*.

Выбор *TypeScript* также обусловлен его популярностью.

*TypeScript* уже давно имеет многочисленных сторонников среди frontend-разработчиков, а последнее время начинает
завоёвывать позиции уже и на backend.

</Notes>

---

- *Чистая Архитектура*
- *React*
- *TypeScript*
- *React Testing Library*

<Notes>

Для модульного тестирования в стартере используется библиотека [Кента Доддса](https://kentcdodds.com/) [*React Testing
Library*](https://testing-library.com/docs/react-testing-library/intro), которая за последнее время получила уже вполне
широкое признание.

</Notes>

---

- *Чистая Архитектура*
- *React*
- *TypeScript*
- *React Testing Library*
- *REST API*

<Notes>

Для хранения значения счётчика используется внешний сервис, взаимодействие с которым осуществляется по REST API.  

</Notes>

---

- *Чистая Архитектура*
  - <i style="color:#33FF33">Single Responsibility Principle (SRP)</i>
  - <i style="color:#33FF33">Open-Closed Principle (OCP)</i>
  - <i style="color:#FF0000">Liskov Substitution Principle (LSP)</i>
  - <i style="color:#33FF33">Interface Segregation Principle (ISP)</i>
  - <i style="color:#33FF33">Dependency Inversion Principle (DIP)</i>

<Notes>

Из принципов *Чистой Архитектуры* - как известно, это принципы *SOLID* - в стартере представлены, все, кроме *Liskov
Substitution Principle*, для применения которого необходимо, как минимум, присутствие иерархии типов.
Но минималистичность предлагаемой предметной области в данном случае не позволяет это сделать.

Отдельным интересным вопросом является обоснование необходимости и достаточности принципов *SOLID*. Например, существуют
[небезосновательные мнения](https://accu.org/index.php/journals/1957), к которым склонен присоединиться и автор, что эти
принципы не лишены избыточности.

Какие-то из них, такие, как *SRP*, *DIP* и *LSP* - главные, первичные, в то время как остальные - производные, вторичные,
присутствие которых может быть оправдано понятным желанием получить красивую аббревиатуру.

Но здесь не об этом.  

</Notes>

---

<p style="font-size: 130px; text-align:center; padding-bottom:140px;">
Frontend и 
<br/> 
Чистая Архитектура
</p>

<Notes>

Вставка отсюда: [Clean Architecture on Frontend presentation](https://github.com/softspiders/ca-on-frontend)

</Notes>

---

# Словарь используемых терминов

<Notes>

Притом что и в этой презентации, и в коде самого стартера используются термины, вполне традиционные для *Чистой
Архитектуры*, эти термины будут непривычны для тех, кто только начинает знакомиться с этой областью, поэтому они
нуждаются в отдельных пояснениях.

Прекрасный разбор терминов и понятий *Чистой Архитектуры*, разрешающий ряд недоразумений, сделан в работе [*Заблуждения
Clean Architecture*](https://habr.com/ru/company/mobileup/blog/335382/).

Перед тем, как перейти к дальнейшему изложению, не погружаясь глубоко в детали и воспользовавшись результатами этой
работы, оставим здесь только то, что необходимо для дальнейшего изложения в виде краткого словаря используемых терминов,
каждый из которых будет снабжён соответствующими пояснениями.

</Notes>

---

- ***Domain***

<Notes>

*Domain* - Модель предметной области.

Является самой стабильной, сущностной составляющей любого программного продукта. 

В понятиях *Чистой Архитектуры* *Domain* означает то же самое, что *бизнес-логика*. Как правило, подразделяется на два
слоя: внутренний - *Entities* и внешний - *Use Cases*.

</Notes>

---

- *Domain*
  - ***Entities***
  - ***Use Cases***

<Notes>

- *Entities* - иногда понимаются буквально, как сущности некоторой предметной области, иногда - как слой *бизнес-логики*,
разделяемый несколькими программными продуктами - системами, приложениями, сервисами. 
- *Use Cases* - логически замкнутые, **самодостаточные** сценарии использования функций (features) системы.
Иногда - в контексте *Чистой Архитектуры* -  совокупность *Use Case* понимается как слой *бизнес-логики*, относящийся к
конкретному программному продукту - в противовес *Entities* - слою бизнес-логики, разделяемому множеством продуктов.

*Use Case* - одно из ключевых понятий архитектуры системы, в частности, с ним тесно связан *Принцип Единой
Ответственности* (*SRP*), который, в свою очередь, является одним из ключевых принципов *SOLID* и, соответственно,
*Чистой Архитектуры*.

</Notes>

---

- *Domain*
  - *Entities*
  - *Use Cases*
- ***Adapters***
  - ***Presenters***
  - ***Gateways***

<Notes>

- *Adapters* - в оригинальной диаграмме *Чистой Архитектуры* для адаптеров выделен отдельный слой под названием
*Interface Adapters*.

*Адаптер* - вспомогательный программный модуль, согласующий интерфейсы двух других модулей. В контексте
*Чистой Архитектуры* адаптеры обычно служат для согласования интерфейсов внутреннего и внешнего архитектурных слоёв.
Типовым случаем является согласование интерфейсов фреймворков и внешних сервисов с интерфейсами *бизнес-логики*.

В коде предлагаемого стартера используются *адаптеры* двух видов:  *презентеры*(*presenters*) и *шлюзы*(*gateways*).

- *Презентеры* - по сути являются адаптерами UI-фреймворков для модулей бизнес-логики.

- *Шлюзы* - адаптеры внешних сервисов, используемых бизнес-логикой.
В сегодняшних системах доступ к внешним сервисам чаще всего обеспечивается через REST API. Наиболее распространённым
видом таких сервисов является сервис доступа к базе данных. Иногда в таких случаях вместо *Gateway* используется термин
*Repository*.

</Notes>

---

- *Domain*
  - *Entities*
  - *Use Cases*
- *Adapters* 
  - *Presenters*
  - *Gateways*
- ***Infrastructure***
  - ***DB***
  - ***UI***

<Notes>

- *Infrastructure* - инфраструктура - всё то, что находится во внешнем слое - следующем за слоем *Interface Adapters*.

Типичными обитателями *Инфраструктуры* являются базы данных (*DB*) и пользовательские интерфейсы (*UI*) со своими
фреймворками.

</Notes>

---

<p style="font-size: 130px; text-align:center; padding-bottom:140px;">
Как это всё
<br/>
выглядит в коде ?
 </p>

<Notes>

Дальнейшее изложение посвящено разбору стартера, в котором принципы *Чистой Архитектуры* реализуются в программном коде.

Как уже говорилось, стартер реализован на *TypeScript*.
При этом важно отметить, что большая часть решений будет применима и в других языках, особенно в языках, поддерживающих
статическую типизацию, таких как *Java*, *Kotlin*, *C#* и т.п.   

</Notes>

---

<Image src={packagesClient0} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Начнём всё-таки с UML-диаграмм. Код совсем близко ;)

Здесь изображена структура директорий клиентского приложения, вполне обычная при разработке на принципах *Чистой
Архитектуры*.

- domain
  - entities
  - usecases
- adapters
  - presenters
  - gateways
- infrastructure
  - ui

Директории верхнего уровня соответствуют одноимённым слоям, за исключением дополнительной директории *Domain*,
включающей директории-слои *Entities* и *Use Cases*.

Это всего лишь один из возможных вариантов организации структуры. При наличии понимания назначения каждой директории,
когда её имя говорит само за себя, структуру можно строить по-разному.

</Notes>

---

<Image src={packagesClient1} style={{ width: '102vw', height: '100vh'}}/>

<Notes>
...

Например, можно сделать её плоской, упразднив корневые директории и разместив оставшиеся на одном уровне, как на этом
слайде.  

Другими словами, в данном случае до тех пор, пока структура не будет определяться какими-то привходящими требованиями,
например, при использовании кодогенератора, ориентированного на жёсткую структуру, приветствуется творческий подход.

</Notes>

---

<Image src={packagesClient} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Это клиентская часть приложения, обозначим её явно.

</Notes>

---

<Image src={packages} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Для полноты картины разместим на диаграмме и серверную часть, реализующую на REST API сервис хранения значения счётчика,
например, на случай перезагрузки клиентского приложения.

Отметим, что так же, как *UI*, сервис, реализующий REST API, относится к инфраструктуре.

</Notes>

---

<Image src={packagesDependencies} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Обозначим design-time-зависимости в целом - на уровне директорий.

Они соответствуют *Правилу Зависимостей* *Чистой Архитектуры*.

</Notes>

---

<Image src={packagesDependenciesFlowControl} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

И в завершении добавим линию потока управления (run-time-зависимостей) - от вершины и до дна стека - от действий
пользователя до реакции сервиса на серверной стороне, которую не будем здесь детализировать.

</Notes>

---

<Image src={layerModule} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Модуль слоя в принципе обычный модуль. 

</Notes>

---

<Image src={layerModule1} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>

---

<Image src={caLayerModulesBase} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>

---

<Image src={caLayerModulesBaseRequired} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>

---

<Image src={caLayerModulesBase1} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>

---

<Image src={caLayerModulesBase2} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>


---

<CodeSurferColumns themes={[naiveTheme, myTheme]}>

<Step>

<Image src={counterResetModule} style={{ width: '100vw', height: '100vh'}}/>

```ts 1:3,5:7 file=../../src/domain/usecases/CounterReset.ts title="CounterReset"
```

</Step>


<Step>

<Image src={counterResetModuleImplementation} style={{ width: '100vw', height: '100vh'}}/>

```ts 9:15 file=../../src/domain/usecases/CounterReset.ts title="CounterReset"
```

</Step>

</CodeSurferColumns>


<Notes>

В качестве примера приведём код бизнес-логики - из *usecases* - *CounterReset*

... 
</Notes>

---

<CodeSurferColumns themes={[myTheme]}>

<Step>

```ts file=../../src/index.tsx title="index.tsx"
```

</Step>

<Step>

```ts file=../../src/infrastructure/ui/App.tsx title="App.tsx"
```

</Step>

<Step>

```ts file=../../src/infrastructure/ui/Counter.tsx title="Counter.tsx"
```

</Step>

</CodeSurferColumns>

---

# СПАСИБО ЗА ВНИМАНИЕ!

---

[Alexander Lapygin](https://github.com/AlexanderLapygin)

---

# Исходники этой презентации

[https://github.com/softspiders/ca-react-rest-api-starter](https://github.com/softspiders/ca-react-rest-api-starter)

---

# Полезные материалы

- [Презентация *О Принципе Инверсии Зависимостей*](https://csb-9kg5y-8d0n41fyp.now.sh)
- [*Заблуждения Clean Architecture*](https://habr.com/ru/company/mobileup/blog/335382/)

---

# Вспомогательные материалы

---

<Image src={template} style={{ width: '102vw', height: '100vh'}}/>

<Notes>
Это шаблон слайда с заголовком и подписью
</Notes>

---

<Image src={beach} style={{ width: '30vw', height: '80vh'}}/>

---

<Image src={konyuhov1} style={{ width: '30vw', height: '80vh'}}/>

---

<Image src={konyuhov2} style={{ width: '70vw', height: '70vh'}}/>

---

<Image src={konyuhov3} style={{ width: '55vw', height: '80vh'}}/>

---

<Image src={konyuhov4} style={{ width: '60vw', height: '80vh'}}/>

---

<Image src={konyuhov5} style={{ width: '70vw', height: '80vh'}}/>

---

<Image src={konyuhov61} style={{ width: '30vw', height: '80vh'}}/>

---

<Image src={konyuhov7} style={{ width: '30vw', height: '80vh'}}/>

---

<CodeSurferColumns themes={[naiveTheme, naiveTheme]}>

<Step>

<Image src={konyuhov1} style={{ width: '30vw', height: '80vh'}}/>

<Image src={konyuhov61} style={{ width: '30vw', height: '80vh'}}/>

</Step>

</CodeSurferColumns>

---

<Image src={nakedInMountains} style={{ width: '60vw', height: '80vh'}}/>

---

<Image src={climbersBunch2} style={{ width: '60vw', height: '80vh'}}/>

<Notes>

"Но мы выбираем трудный путь..."

На самом деле он оптимальный.

Что мы оптимизируем ?

Масштабирование во времени - устойчивость развития.

</Notes>

---

<p style="font-size: 130px; text-align:center; padding-bottom:140px;">
<i>Правило Зависимостей</i>
<br/>
и модули
</p>

<Notes>
...

 *Правило Зависимостей*

...
</Notes>

---

<CodeSurferColumns themes={[naiveTheme, naiveTheme]}>

<Step>

<Image src={modulesCosmicStation} style={{ width: '100vw', height: '70vh'}}/>

<Image src={legoModules} style={{ width: '50vw', height: '70vh'}}/>

</Step>

</CodeSurferColumns>

<Notes>

Что общего в этих изображениях ?

</Notes>
