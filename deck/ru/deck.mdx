import { Image, Notes, Head } from "mdx-deck";

import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";

import {
  vsDark as naiveTheme,
  nightOwl as smartTheme
} from "@code-surfer/themes"


import myTheme from './lib/theme'
export const theme = myTheme
//export const theme = smartTheme;

import beach from "./diagrams/beach.jpg";
import konyuhov1 from "./diagrams/konyuhov1.jpg";
import konyuhov2 from "./diagrams/konyuhov2.jpg";
import konyuhov3 from "./diagrams/konyuhov3.jpg";
import konyuhov4 from "./diagrams/konyuhov4.jpg";
import konyuhov5 from "./diagrams/konyuhov5.jpg";
import konyuhov6 from "./diagrams/konyuhov6.jpg";
import konyuhov61 from "./diagrams/konyuhov61.jpg";
import konyuhov7 from "./diagrams/konyuhov7.jpg";
import nakedInMountains from "./diagrams/nakedInMountains.jpg";
import modulesCosmicStation from "./diagrams/modulesCosmicStation.jpg";
import legoModules from "./diagrams/legoModules.png";

 
import climbersBunch2 from "./diagrams/climbersBunch2.jpg";

import packagesClient0 from "./diagrams/packagesClient0.svg";
import packagesClient from "./diagrams/packagesClient.svg";
import packages from "./diagrams/packages.svg";
import packagesDependencies from "./diagrams/packagesDependencies.svg";
import packagesDependenciesFlowControl from "./diagrams/packagesDependenciesFlowControl.svg";

import layerModule from "./diagrams/layerModule.svg";
import layerModule1 from "./diagrams/layerModule1.svg";

import caLayerModulesBase from "./diagrams/caLayerModulesBase.svg";
import caLayerModulesBaseRequired from "./diagrams/caLayerModulesBaseRequired.svg";
import caLayerModulesBase1 from "./diagrams/caLayerModulesBase1.svg";
import caLayerModulesBase2 from "./diagrams/caLayerModulesBase2.svg";

import counterResetModule from "./diagrams/counterResetModule.svg";
import counterResetModuleImplementation from "./diagrams/counterResetModuleImplementation.svg";

import template from "./diagrams/template.svg";

<Head>
  <title>Starter for Clean Architecture</title>
</Head>

---

<p style="font-size: 70px; text-align:left; padding-bottom:100px;">
 <span style="font-size: 120px;">How to perceive this presentation</span>
 <br/>
 <br/>
 <ul>
    <li><i>Speaker notes</i> mode:</li>
    <ul>
        <li><i>Alt+P</i> - on Windows</li>
        <li><i>Option+P</i> - on Mac</li>
    </ul>
    <li>Size tuning:</li>
    <ul>
        <li><i>F11</i> - fullscreen mode enabling</li>
        <li><i>Ctrl + '-/+'</i> - decrease/increase font size</li>
    </ul>
</ul>
</p>

<Notes>

Как смотреть эту презентацию

Эту презентацию можно будет повторно пересмотреть-перечитать в режиме докладчика, при котором одновременно виден слайд и
сопровождающий его текст.

Режим докладчика включается комбинацией клавиш *Alt+P* - на Windows и *Option+P* - на Mac.

Комбинацией клавиш *Ctrl + -/+* можно уменьшать/увеличивать размер шрифта

</Notes>

---

<p style="font-size: 150px; text-align:center; padding-bottom:140px;">
Starter for
<br/>
Client Applications
</p>

<Notes>

В этой презентации будет рассказано о стартере для клиентских приложений, разрабатываемых
...
</Notes>

---

<p style="font-size: 150px; text-align:center; padding-bottom:80px;">
On the Clean Architecture
</p>

<Notes>
...

на принципах *Чистой Архитектуры*.

Несмотря на то, что предметная область и, соответственно, бизнес-логика стартера предельно минималистичны - это
простейший счётчик с функциями инкремента и сброса, рассмотрение всех нужных аспектов трудно уместить в одной
презентации.  

Поэтому будет показано только наиболее существенное, а именно то, как принципы *Чистой Архитектуры* могут быть
представлены в коде языка, поддерживающего понятие интерфейса. А поскольку здесь рассматривается специфика клиентских
приложений, то для этой цели лучше всего подойдёт *TypeScript*, язык, который в среде frontend-разработчиков уже сегодня
имеет многочисленных сторонников, и который последнее время начинает завоёвывать позиции уже и на backend (см., например,
[*NestJS*](https://nestjs.com/)). 

От аудитории желательно присутствие хотя бы минимального предварительного понимания существа проблем, решаемых *Чистой
Архитектурой*. Ну а для тех, кому эта тема совсем незнакома, сформулируем кратко: принципы *Чистой Архитектуры*
направлены на обеспечение долгого и устойчивого развития программного продукта - его, если так можно выразиться,
"масштабируемость во времени".  

</Notes>

---

<p style="font-size: 100px; text-align:center; padding-bottom:140px;">
Key Features
</p>

<Notes>

Ключевые свойства стартера:

...
</Notes>

---

- *Clean Architecture*

<Notes>
...

*Чистая Архитектура*

...
</Notes>

---

- *Clean Architecture*
- *React*

<Notes>
...

*React*

...
</Notes>

---

- *Clean Architecture*
- *React*
- *TypeScript*

<Notes>
...

*TypeScript*

...
</Notes>

---

- *Clean Architecture*
- *React*
- *TypeScript*
- *React Testing Library*

<Notes>
...

Для модульного тестирования используется библиотека Кента Доддса *React Testing Library*. Последнее время она получила
уже вполне широкое признание среди разработчиков.

...
</Notes>

---

- *Clean Architecture*
- *React*
- *TypeScript*
- *React Testing Library*
- *REST API*

<Notes>
...

*Взаимодействие с сервисами по REST API*

Последние два пункта заслуживают отдельного рассмотрения, поэтому здесь подробно освещаться не будут. 

</Notes>

---

- *Clean Architecture*
  - <i style="color:#33FF33">Single Responsibility Principle (SRP)</i>
  - <i style="color:#33FF33">Open-Closed Principle (OCP)</i>
  - <i style="color:#FF0000">Liskov Substitution Principle (LSP)</i>
  - <i style="color:#33FF33">Interface Segregation Principle (ISP)</i>
  - <i style="color:#33FF33">Dependency Inversion Principle (DIP)</i>

<Notes>

Из принципов *Чистой Архитектуры* - как известно, это принципы *SOLID*, здесь представлены, пожалуй, все, кроме *Liskov
Substitution Principle*, для применения которого необходимо, как минимум, присутствие иерархии типов.
Но минималистичность предлагаемой предметной области в данном случае не позволяет это сделать.

Отдельным интересным вопросом является обоснование необходимости и достаточности принципов *SOLID*. Например, существуют
[небезосновательные мнения](https://accu.org/index.php/journals/1957), к которым склонен присоединиться и автор, что эти
принципы не лишены избыточности.

Какие-то из них, такие, как *SRP*, *DIP* и *LSP* - главные, первичные, в то время как остальные - производные, вторичные,
присутствие которых может быть оправдано понятным желанием получить красивую аббревиатуру.

Но здесь не об этом.  

</Notes>

---

<p style="font-size: 130px; text-align:center; padding-bottom:140px;">
Clean Architecture
<br/> 
and frontend
</p>

<Notes>

Вставка отсюда: [Clean Architecture on Frontend presentation](https://github.com/softspiders/ca-on-frontend)

</Notes>

---

# Terminology

<Notes>

В этой презентации и в коде стартера используются именования, вполне традиционные для Чистой Архитектуры, но для тех,
кто только начинает знакомиться с этой областью, некоторые понятия нуждаются в пояснениях.

</Notes>

---

# Понятийный словарь

<Notes>

Не вдаваясь в детали, приведём краткий словарь используемых понятий с соответствующими комментариями.

</Notes>

---

- *Domain*

<Notes>

Domain - Модель предметной области. Является самой стабильной, сущностной составляющей любого программного продукта. 
В контексте Чистой Архитектуры *Domain* означает то же самое, что *бизнес логика*. Как правило, подразделяется на два
слоя: внутренний - *Entities* и внешний - *Use Cases*.

...
</Notes>

---

- *Domain*
  - *Entities*
  - *Use Cases*

<Notes>
...

- *Entities* - иногда понимаются буквально, как сущности некоторой предметной области, иногда в некоторых контекстах -
как слой *бизнес-логики*, разделяемый несколькими программными продуктами - системами, приложениями, сервисами, ... 
- *Use Cases* - логически замкнутые, **самодостаточные** сценарии использования функциональностей (features) системы.
В некоторых контекстах совокупность *Use Cases* понимается, как слой *бизнес-логики*, относящийся к конкретному
программному продукту - в противовес *Entities* - слою бизнес-логики, как уже было сказано, разделяемому множеством
продуктов.

*Use Case* - одно из ключевых понятий Чистой Архитектуры, поскольку на нём базируется *SRP* - *Принцип Единой
Ответственности*, который, несмотря на своё неудачное название (на чём здесь не будем останавливаться), является одним
из самых главных принципов *SOLID* и, соответственно, Чистой Архитектуры.

...
</Notes>

---

- *Domain*
  - *Entities*
  - *Use Cases*
- Adapters 
  - gateways (repositories)
  - presenters
- UI (frameworks)
- Backend frameworks
- DB


<Notes>
...

- *Adapters* - адаптеры - программные модули, согласующие интерфейсы внутренних и внешних слоёв. Чаше всего имеется в
виду согласование интерфейсов фреймворков и внешних систем с интерфейсами *бизнес-логики*

...
</Notes>

---

<p style="font-size: 130px; text-align:center; padding-bottom:140px;">
Dependency Rule
<br/>
and modules
</p>

---

<CodeSurferColumns themes={[naiveTheme, naiveTheme]}>

<Step>

<Image src={modulesCosmicStation} style={{ width: '100vw', height: '70vh'}}/>

<Image src={legoModules} style={{ width: '30vw', height: '70vh'}}/>

</Step>

</CodeSurferColumns>

<Notes>

Что общего ?

</Notes>

---

<Image src={packagesClient0} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Здесь изображена структура директорий (packages) клиентского приложения, вполне обычная при разработке на принципах
Чистой Архитектуры.

- domain
  - entities
  - usecases
- ui
- adapters
  - presenters
  - gateways

Самое время дать пояснения используемым названиям.

</Notes>

---

<Image src={packagesClient} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Здесь изображена структура директорий (packages) клиенского приложения, вполне обычная при разработке на принципах
Чистой Архитектуры.

- domain
  - entities
  - usecases
- ui
- adapters
  - presenters
  - gateways

</Notes>

---

<Image src={packages} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Для полноты картины разместим на диаграмме серверную часть приложения

</Notes>

---

<Image src={packagesDependencies} style={{ width: '102vw', height: '100vh'}}/>

---

<Image src={packagesDependenciesFlowControl} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Это вариант, когда сервис является частью приложения, его backend-составляющей. 

</Notes>

---

<Image src={layerModule} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

Модуль слоя в принципе обычный модуль. 

</Notes>

---

<Image src={layerModule1} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>

---

<Image src={caLayerModulesBase} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>

---

<Image src={caLayerModulesBaseRequired} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>

---

<Image src={caLayerModulesBase1} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>

---

<Image src={caLayerModulesBase2} style={{ width: '102vw', height: '100vh'}}/>

<Notes>

... 

</Notes>


---

<CodeSurferColumns themes={[naiveTheme, myTheme]}>

<Step>

<Image src={counterResetModule} style={{ width: '100vw', height: '100vh'}}/>

```ts 1:3,5:7 file=../../src/domain/usecases/CounterReset.ts title="CounterReset"
```

</Step>


<Step>

<Image src={counterResetModuleImplementation} style={{ width: '100vw', height: '100vh'}}/>

```ts 9:15 file=../../src/domain/usecases/CounterReset.ts title="CounterReset"
```

</Step>

</CodeSurferColumns>


<Notes>

В качестве примера приведём код бизнес-логики - из *usecases* - *CounterReset*

... 
</Notes>

---

<CodeSurferColumns themes={[myTheme]}>

<Step>

```ts file=../../src/index.tsx title="index.tsx"
```

</Step>

<Step>

```ts file=../../src/ui/App.tsx title="App.tsx"
```

</Step>

<Step>

```ts file=../../src/ui/Counter.tsx title="Counter.tsx"
```

</Step>

</CodeSurferColumns>

---

# THANK YOU!

---

[Alexander Lapygin](https://github.com/AlexanderLapygin)

---

# Sources

[https://github.com/softspiders/ca-react-rest-api-starter](https://github.com/softspiders/ca-react-rest-api-starter)

---

# Useful materials

[*Dependency Inversion Principle* presentation](https://csb-9kg5y-8d0n41fyp.now.sh)

---

# Вспомогательные материалы

---

<Image src={template} style={{ width: '102vw', height: '100vh'}}/>

<Notes>
Это шаблон слайда с заголовком и подписью
</Notes>

---

<Image src={beach} style={{ width: '30vw', height: '80vh'}}/>

---

<Image src={konyuhov1} style={{ width: '30vw', height: '80vh'}}/>

---

<Image src={konyuhov2} style={{ width: '70vw', height: '70vh'}}/>

---

<Image src={konyuhov3} style={{ width: '55vw', height: '80vh'}}/>

---

<Image src={konyuhov4} style={{ width: '60vw', height: '80vh'}}/>

---

<Image src={konyuhov5} style={{ width: '70vw', height: '80vh'}}/>

---

<Image src={konyuhov61} style={{ width: '30vw', height: '80vh'}}/>

---

<Image src={konyuhov7} style={{ width: '30vw', height: '80vh'}}/>

---

<CodeSurferColumns themes={[naiveTheme, naiveTheme]}>

<Step>

<Image src={konyuhov1} style={{ width: '30vw', height: '80vh'}}/>

<Image src={konyuhov61} style={{ width: '30vw', height: '80vh'}}/>

</Step>

</CodeSurferColumns>

---

<Image src={nakedInMountains} style={{ width: '60vw', height: '80vh'}}/>

---

<Image src={climbersBunch2} style={{ width: '60vw', height: '80vh'}}/>

<Notes>

"Но мы выбираем трудный путь..."

На самом деле он оптимальный.

Что мы оптимизируем ?

Масштабирование во времени - устойчивость развития.

</Notes>
